---
title: "Inference For Numerical Data"
author: "Cameron Smith"
date: "10/25/2018"
output: bookdown::html_document2
---

```{r setup, include=FALSE, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE, fig.align='center'}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyverse)
library(infer)
library(openintro)
library(ggplot2)
```
<center>
#Bootstrapping for estimating a parameter
</center>
##Generate bootstrap distribution for median
When building a bootstrap distribution for a single statistic, we first generate a series of bootstrap resamples, and then record the relevant statistic (in this case, the median) of each distribution.

In this exercise, the `tidyverse` packages, including `ggplot2` have been loaded for you, as has `infer`.
```{r}
manhattan <- read.csv("https://assets.datacamp.com/production/course_5103/datasets/manhattan.csv")
# Generate bootstrap distribution of medians
rent_ci_med <- manhattan %>%
  # Specify the variable of interest
  specify(response = rent) %>%  
  # Generate 15000 bootstrap samples
  generate(reps = 15000, type = "bootstrap") %>% 
  # Calculate the median of each bootstrap sample
  calculate(stat = "median")

# View the structure of rent_ci_med
str(rent_ci_med)

# Plot a histogram of rent_ci_med
ggplot(rent_ci_med, aes(stat)) +
  geom_histogram(binwidth = 50)

```
##Calculate bootstrap interval using both methods
Using our bootstrap distribution from an earlier exercise, we can calculate bootstrap intervals for the median price of 1 bedroom apartments in Manhattan. Remember that we saved the bootsrap distribution as `rent_ci_med`.

```{r}  
# Percentile method
rent_ci_med %>%
  summarize(l = quantile(stat, 0.025),
            u = quantile(stat, 0.975))

# Standard error method

# Calculate observed median
rent_med_obs <- manhattan %>%
  # Calculate observed median rent
  summarize(median(rent)) %>%
  # Extract numerical value
  pull()                      

# Determine critical value
t_star <- qt(0.975, df = nrow(manhattan) - 1)

# Construct interval
rent_ci_med %>%
  summarize(boot_se = sd(stat)) %>%
  summarize(l = rent_med_obs - t_star * boot_se,
            u = rent_med_obs + t_star * boot_se)
```
##Which method more appropriate: percentile or SE?
Which method is more appropriate for calculating the bootstrap confidence interval for the median rent of 1 BR apartments in Manhattan?

*`Standard error method`

##Doctor visits during pregnancy
The state of North Carolina released to the public a large data set containing information on births recorded in this state. This data set has been of interest to medical researchers who are studying the relation between habits and practices of expectant mothers and the birth of their children. The `ncbirths` dataset (which is already loaded for you) is a random sample of 1,000 cases from this data set. Among other variables, the number of doctor's visits (`visits`) the mother had throughout the pregnancy is recorded. Which of the following is false about the distribution of `visits`?

*`The number of doctor's visits for one of the mothers in the dataset is missing.`


##Average number of doctor's visits
Next, we construct a bootstrap interval for the average number of doctor's visits during pregnancy.
```{r}
sims <- 15000
MED <- numeric(sims)
for(i in 1:sims) {
  bss <- sample(manhattan$rent, 20, replace = TRUE)
  MED[i] <- median(bss)
}
CI_perc <- quantile(MED, probs = c(.025, .975))
CI_perc

# Remove NA visits
ncbirths_complete_visits <- ncbirths %>%
  filter(!is.na(visits))

# Generate 15000 bootstrap means
visit_ci_mean <- ncbirths_complete_visits %>%
  specify(response = visits) %>%
  generate(reps = 15000, type = "bootstrap") %>%
  calculate(stat = "mean")
  
# Calculate the 90% CI via percentile method
visit_ci_mean %>%
  summarize(l = quantile(stat, 0.05),
            u = quantile(stat, 0.95))
```

##SD of number of doctor's visits
Suppose now we're interested in the standard deviation of the number of doctor's visits throughout pregnancy.
```{r}
# Calculate 15000 bootstrap SDs
visit_ci_sd <- ncbirths_complete_visits %>%
  specify(response = visits) %>%
  generate(reps = 15000, type = "bootstrap") %>%
  calculate(stat = "sd")
  
# Calculate the 90% CI via percentile method
visit_ci_sd %>%
  summarize(l = quantile(stat, 0.05),
            u = quantile(stat, 0.95))
```

##Test for median price of 1 BR apartments in Manhattan
Let's turn our attention back to Manhattan apartments. We would like to evaluate whether these data provide evidence that the median rent of 1 BR apartments in Manhattan is greater than $2,500.
```{r}
# Generate 15000 bootstrap samples centered at null
rent_med_ht <- manhattan %>%
  specify(response = rent) %>%
  hypothesize(null = "point", med = 2500) %>% 
  generate(reps = 15000, type = "bootstrap") %>% 
  calculate(stat = "median")
  
# Calculate observed median
rent_med_obs <- manhattan %>%
  summarize(median(rent)) %>%
  pull()

# Calculate p-value
rent_med_ht %>%
  filter(stat > rent_med_obs) %>%
  summarize(n() / 15000)
```

##Conclude the hypothesis test on median
What is the conclusion of the hypothesis test at the 5% significance level?

*`We fail to reject `$H_0$` since the p-value is above the significance level, and conclude that the data do not provide convincing evidence that median rent of 1 BR apartments in Manhattan is greater than $2500.`

##Test for average weight of babies
We'll wrap up inference on a single parameter of a numerical distribution by revisiting the ncbirths dataset, specifically the weight variable indicating the birth weight of the baby. Do these data provide convincing evidence that the average birth weight of babies born in North Carolina is different than 7 pounds?
```{r}
# Generate 1500 bootstrap means centered at null
weight_mean_ht <- ncbirths %>%
  specify(response = weight) %>%
  hypothesize(null = "point", mu = 7) %>% 
  generate(reps = 1500, type = "bootstrap") %>% 
  calculate(stat = "mean")
  
# Calculate observed mean
weight_mean_obs <- ncbirths %>%
  summarize(mean(weight)) %>%
  pull()

# Calculate p-value
weight_mean_ht %>%
  filter(stat > weight_mean_obs) %>%
  summarize(p_val = 2 * n() / 1500)
```

#Introducing the t-distribution
##When to t?
Which of the following describes best why we might need to use the t-distribution for inference?

*`population standard deviation is unknown`

##Probabilities under the t-distribution
We can use the `pt` function to find probabilities under the t-distribution. For a given cutoff value `q` and a given degrees of freedom `df`, `pt(q, df)` gives us the probability under the t-distribution with `df` degrees of freedom for values of `t` less than `q`. In other words, $P(tdf<T)$ = `pt(q = T, df)`.
```{r}
# P(T < 3) for df = 10
(x <- pt(3, df = 10))

# P(T > 3) for df = 10
(y <- 1 - x)

# P(T > 3) for df = 100
(z <- 1 - pt(3, df = 100))

# Comparison
y == z
y > z
y < z
```

##Cutoffs under the t-distribution
We can use the `qt()` function to find cutoffs under the t-distribution. For a given probability `p` and a given degrees of freedom `df`, `qt(p, df)` gives us the cutoff value for the t-distribution with `df` degrees of freedom for which the probability under the curve is `p`. In other words, if $P(tdf<T)=p$, then $T$ = `qt(p, df)`. For example, if $T$ corresponds to the 95th percentile of a distribution, $p=0.95$. The "middle 95%" means from `p = 0.025` to `p = 0.975`.
```{r}
# 95th percentile for df = 10
(x <- qt(0.95, df = 10))

# upper bound of middle 95th percent for df = 10
(y <- qt(0.975, df = 10))

# upper bound of middle 95th percent for df = 100
(z <- qt(0.975, df = 100))

# Comparison
y == z
y > z
y < z
```

##Average commute time of Americans
Each year since 2005, the US Census Bureau surveys about 3.5 million households with The __American Community Survey__ (ACS). Data collected from the ACS have been crucial in government and policy decisions, helping to determine the allocation of federal and state funds each year. Data from the 2012 ACS is available in the `acs12` dataset.
```{r}
# Subset for employed respondents
acs12_emp <- acs12 %>%
  filter(employment == "employed")

# Construct 95% CI for avg time_to_work
t.test(acs12_emp$time_to_work, conf.level = 0.95)
```

##
```{r}


```